import {defineConfig, defineAutogeneratedFile} from "@anio-software/enkore"
import {defineTargetOptions} from "@anio-software/enkore.target-js-node"
import {scandir, type ScandirEntry, readFileString} from "@anio-software/pkg.node-fs"
import path from "node:path"
import {fileURLToPath} from "node:url"

function filterEntry(e: ScandirEntry) {
	if (e.type !== "file:regular") return false
	if (!e.name.includes("Factory")) return false
	if (!e.name.endsWith(".ts")) return false

	return true
}

function mapEntry(e: ScandirEntry) {
	return e.relativePath.slice(0, -("Factory.ts".length))
}

const __dirname = path.dirname(fileURLToPath(import.meta.url))

const apiMethods = (await scandir(
	path.join(__dirname, "project", "src", "targetIntegration", "public"),
	{
		sort: "alphabetical:ascending",
		filter: filterEntry
	}
)).map(mapEntry)

const autogenerateApiMethods = (await scandir(
	path.join(__dirname, "project", "src", "autogenerate", "public"),
	{
		sort: "alphabetical:ascending",
		filter: filterEntry
	}
)).map(mapEntry)

const isPublicRelease = (
	process.env?.RELEASE_VERSION ?? ""
).startsWith("vp")

export const config: unknown = defineConfig({
	target: {
		name: "js-node",
		options: defineTargetOptions({
			registry: {
				"anioSoftware": {
					url: "https://npm-registry.anio.software",
					authTokenFilePath: "secrets/anio_npm_auth_token",
					clientPrivateKeyFilePath: "secrets/npm_client.pkey",
					clientCertificateFilePath: "secrets/npm_client.cert"
				}
			},

			packageSourceRegistryByScope: {
				"@anio-software": {
					registry: "anioSoftware"
				}
			},

			publish: [{
				registry: "anioSoftware",
				tag: isPublicRelease ? "latest" : "canary"
			}]
		})
	},

	autogeneratedFiles: [
		defineAutogeneratedFile({
			destinationPath: `project/export/targetIntegration/getTargetIntegrationAPIMethodNames.ts`,
			generator() {
				return `export function getTargetIntegrationAPIMethodNames() {
	return ${JSON.stringify(apiMethods)}
}\n`
			}
		}),
		defineAutogeneratedFile({
			destinationPath: `project/export/autogenerate/getAutogenerateAPIMethodNames.ts`,
			generator() {
				return `export function getAutogenerateAPIMethodNames() {
	return ${JSON.stringify(autogenerateApiMethods)}
}\n`
			}
		}),
		defineAutogeneratedFile({
			destinationPath: `project/export/getUsedEnkoreSpecPackageVersion.ts`,
			async generator() {
				const {default: specPackageJSON} = await import(
					// @ts-expect-error
					`@anio-software/enkore-private.spec/package.json`, {
						with: {
							type: "json"
						}
					}
				)

				return `export function getUsedEnkoreSpecPackageVersion() {
	return ${JSON.stringify(specPackageJSON.version)}
}\n`
			}
		}),
		defineAutogeneratedFile({
			destinationPath: `project/src/__getToolchainVersionToInstall.ts`,
			generator(session) {
				const devDeps = session.project.packageJSON["devDependencies"]!
				const toolchainTypes = devDeps["@anio-software/enkore-private.target-js-toolchain_types"]!
				const tuple = toolchainTypes.split(".")

				return `export const __getToolchainVersionToInstall = function() { return ${tuple[2]}; };\n`
			}
		}),

		defineAutogeneratedFile({
			destinationPath: `project/export/project/__aggregatedExports.ts`,
			async generator(session) {
				const template = await readFileString(
					path.join(session.project.root, "project", "embeds", "projectAPI", "moduleTemplate.ts")
				)

				let code = `import {generateProjectAPIContext} from "#~src/targetIntegration/generateProjectAPIContext.ts"\n`

				code += `const __projectAPIContext = await generateProjectAPIContext(["inferFromCLIArgs"]);\n`

				code += template.split(`"%%CONTEXT_DATA%%"`).join(`__projectAPIContext`)

				return code
			}
		})
	]
})
