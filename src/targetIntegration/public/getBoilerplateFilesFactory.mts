import type {API} from "#~src/targetIntegration/API.d.mts"
import type {APIContext} from "#~src/targetIntegration/APIContext.d.mts"
import {createEntity} from "@anio-software/enkore-private.spec"
import {getAsset} from "@fourtune/realm-js/v0/assets"
import {targetBoilerplateFileMarkerUUID} from "@anio-software/enkore-private.spec/uuid"
import {_getRegistryMap} from "../_getRegistryMap.mts"
import {_npmRegistryToConfigString} from "../_npmRegistryToConfigString.mts"
import type {Registry} from "../InternalData.d.mts"

const impl: API["getBoilerplateFiles"] = async function(
	this: APIContext, session
) {
	function defineFile(path: string, content: string, fullyManagedByEnkore?: boolean, startComment?: string) {
		const header = (() => {
			const scom = startComment && startComment.length ? startComment : "//"
			let tmp = ``

			tmp += `${scom} DO NOT EDIT THIS FILE\n`
			tmp += `${scom} ${targetBoilerplateFileMarkerUUID}\n`

			return tmp
		})()

		return createEntity("EnkoreBoilerplateFile", 0, 0, {
			requestedBy: "target",
			content: `${header}${content}`,
			path,
			fullyManagedByEnkore
		})
	}

	const tsconfigBase = JSON.parse(getAsset("text://tsconfig/base.json") as string)
	const targetOptions = session.target.getOptions("js")

	if (targetOptions.environment.includes("node")) {
		tsconfigBase.compilerOptions.types.push("@types/node")

		tsconfigBase.compilerOptions.lib.push("esnext")
	}

	if (targetOptions.environment.includes("web")) {
		tsconfigBase.compilerOptions.types.push("@types/web")

		tsconfigBase.compilerOptions.lib.push("dom")
	}

	const registryMap = _getRegistryMap(targetOptions)

	let npmConfig = ""

	npmConfig += `\n`
	npmConfig += `# DO NOT CHANGE THIS CONFIGURATION\n`
	npmConfig += `# THIS CONFIG IS SOLELY FOR **INSTALLING** PACKAGES`
	npmConfig += ` AND IS MANAGED AUTOMATICALLY\n`
	npmConfig += `# TO CONFIGURE PUBLISHING USE /enkore.config.mts\n`

	if (targetOptions.packageSourceRegistryByScope) {
		const definedScopes: {
			scope: string
			registryId: string
			registry: Registry
		}[] = []

		for (const scope in targetOptions.packageSourceRegistryByScope) {
			const {registry} = targetOptions.packageSourceRegistryByScope[scope]

			if (!registryMap.has(registry)) {
				session.enkore.emitMessage(
					"error", `referenced undefined registry '${registry}'`
				)

				return []
			}

			definedScopes.push({
				scope,
				registryId: registry,
				registry: registryMap.get(registry)!
			})
		}

		// sort for stable output
		definedScopes.sort((a, b) => {
			return a.scope.localeCompare(b.scope, "en")
		})

		const configuredRegistries: Map<string, true> = new Map()

		// configure registries first and only do it once per registry
		for (const {registryId, registry} of definedScopes) {
			if (configuredRegistries.has(registryId)) {
				continue
			}

			npmConfig += _npmRegistryToConfigString(registry, {
				includeAuthToken: false,
				scope: false
			})

			configuredRegistries.set(registryId, true)
		}

		for (const {scope, registry} of definedScopes) {
			npmConfig += _npmRegistryToConfigString({
				url: registry.url
			}, {scope, includeAuthToken: false})
		}
	}

	return [
		defineFile("tsconfig.json", getAsset("text://tsconfig/tsconfig.json") as string, true),
		defineFile("tsconfig/base.json", JSON.stringify(tsconfigBase, null, 4) + "\n", true),
		defineFile("tsconfig/enkore-config.json", getAsset("text://tsconfig/enkore-config.json") as string, true),
		defineFile("tsconfig/src.json", getAsset("text://tsconfig/src.json") as string, true),
		defineFile("tsconfig/embeds.json", getAsset("text://tsconfig/embeds.json") as string, true),
		defineFile(
			".npmrc",
			npmConfig,
			true,
			"#"
		)
	]
}

export function getBoilerplateFilesFactory(context: APIContext) {
	return impl!.bind(context)
}
