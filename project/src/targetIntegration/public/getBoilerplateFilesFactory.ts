import type {API} from "#~src/targetIntegration/API.ts"
import type {APIContext} from "#~src/targetIntegration/APIContext.ts"
import {createEntity} from "@anio-software/enkore-private.spec"
import {getEmbedAsString} from "@anio-software/enkore.target-js-node/project"
import {targetBoilerplateFileMarkerUUID} from "@anio-software/enkore-private.spec/uuid"
import {_getRegistryMap} from "../_getRegistryMap.ts"
import {_npmRegistryToConfigString} from "../_npmRegistryToConfigString.ts"
import type {Registry} from "../InternalData.ts"
import {
	isNodeTarget,
	isReactTarget,
	isWebTarget
} from "@anio-software/enkore-private.target-js-utils"

const impl: API["getBoilerplateFiles"] = async function(
	this: APIContext, session
) {
	function defineFile(path: string, content: string, fullyManagedByEnkore?: boolean, startComment?: string) {
		const header = (() => {
			const scom = startComment && startComment.length ? startComment : "//"
			let tmp = ``

			tmp += `${scom} DO NOT EDIT THIS FILE\n`
			tmp += `${scom} ${targetBoilerplateFileMarkerUUID}\n`

			return tmp
		})()

		return createEntity("EnkoreBoilerplateFile", 0, 0, {
			requestedBy: "target",
			content: `${header}${content}`,
			path,
			fullyManagedByEnkore
		})
	}

	const tsconfigBase = JSON.parse(getEmbedAsString("text://tsconfig/base.json") as string)
	const targetOptions = session.target.getOptions(this.target)

	if (isNodeTarget(this.target)) {
		tsconfigBase.compilerOptions.types.push("@types/node")
	}

	if (isWebTarget(this.target)) {
		tsconfigBase.compilerOptions.types.push("@types/web")

		tsconfigBase.compilerOptions.plugins = [{
			name: "css-modules-ts-plugin"
		}]
	}

	if (isReactTarget(this.target)) {
		tsconfigBase.compilerOptions.types.push("@types/react")
		tsconfigBase.compilerOptions.types.push("@types/react-dom")
		tsconfigBase.compilerOptions.jsx = "react-jsx"
	}

	const registryMap = _getRegistryMap(targetOptions)

	let npmConfig = ""

	npmConfig += `\n`
	npmConfig += `# DO NOT CHANGE THIS CONFIGURATION\n`
	npmConfig += `# THIS CONFIG IS SOLELY FOR **INSTALLING** PACKAGES`
	npmConfig += ` AND IS MANAGED AUTOMATICALLY\n`
	npmConfig += `# TO CONFIGURE PUBLISHING USE /enkore.config.mts\n`

	if (targetOptions.packageSourceRegistryByScope) {
		const definedScopes: {
			scope: string
			registryId: string
			registry: Registry
		}[] = []

		for (const scope in targetOptions.packageSourceRegistryByScope) {
			const {registry} = targetOptions.packageSourceRegistryByScope[scope]

			if (!registryMap.has(registry)) {
				session.enkore.emitMessage(
					"error", `referenced undefined registry '${registry}'`
				)

				return []
			}

			definedScopes.push({
				scope,
				registryId: registry,
				registry: registryMap.get(registry)!
			})
		}

		// sort for stable output
		definedScopes.sort((a, b) => {
			return a.scope.localeCompare(b.scope, "en")
		})

		const configuredRegistries: Map<string, true> = new Map()

		// configure registries first and only do it once per registry
		for (const {registryId, registry} of definedScopes) {
			if (configuredRegistries.has(registryId)) {
				continue
			}

			npmConfig += _npmRegistryToConfigString(registry, {
				includeAuthToken: false,
				scope: false
			})

			configuredRegistries.set(registryId, true)
		}

		for (const {scope, registry} of definedScopes) {
			npmConfig += _npmRegistryToConfigString({
				url: registry.url
			}, {scope, includeAuthToken: false})
		}
	}

	return [
		defineFile("tsconfig.json", getEmbedAsString("text://tsconfig/tsconfig.json") as string, true),
		defineFile("tsconfig/base.json", JSON.stringify(tsconfigBase, null, 4) + "\n", true),
		defineFile("tsconfig/enkore-config.json", getEmbedAsString("text://tsconfig/enkore-config.json") as string, true),
		defineFile("tsconfig/src.json", getEmbedAsString("text://tsconfig/src.json") as string, true),
		defineFile("tsconfig/embeds.json", getEmbedAsString("text://tsconfig/embeds.json") as string, true),
		defineFile(
			".npmrc",
			npmConfig,
			true,
			"#"
		)
	]
}

export function getBoilerplateFilesFactory(context: APIContext) {
	return impl!.bind(context)
}
